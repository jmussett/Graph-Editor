{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\GraphEditor.svelte",
    "..\\..\\Node.svelte",
    "..\\..\\NodeRelation.svelte",
    "..\\..\\Draggable.svelte",
    "..\\..\\Socket.svelte",
    "..\\..\\Selectable.svelte"
  ],
  "sourcesContent": [
    "<script>\r\n \timport { onMount } from 'svelte';\r\n\r\n\timport Node from \"./Node.svelte\";\r\n\timport NodeRelation from \"./NodeRelation.svelte\";\r\n\timport Layout from \"./Layout.js\";\r\n\r\n\texport let graph;\r\n\r\n\tonMount(() => {\r\n\t\tvar layout = new Layout();\r\n\t\tgraph = layout.initializeGraph(graph);\r\n\t});\r\n\r\n\tlet display;\r\n\r\n\t$: {\r\n\t\tfor (let i = 0; i < graph.relations.length; i++) {\r\n\t\t\tlet relation = graph.relations[i];\r\n\r\n\t\t\tlet sourceNode = graph.nodes[relation.sourceNodeIndex];\r\n\t\t\tlet sourceSocket = sourceNode.outputs[relation.sourceSocketIndex];\r\n\t\t\tlet targetNode = graph.nodes[relation.targetNodeIndex];\r\n\t\t\tlet targetSocket = targetNode.inputs[relation.targetSocketIndex];\r\n\r\n\t\t\tgraph.relations[i].sourcePosition = sourceSocket.position;\r\n\t\t\tgraph.relations[i].targetPosition = targetSocket.position;\r\n\t\t}\r\n\t}\r\n\r\n\tlet click = e => graph.nodes.forEach(n => n.events && n.events.click && n.events.click(e));\r\n\tlet move = e => graph.nodes.forEach(n => n.events && n.events.move && n.events.move(e));\r\n\tlet stop = e => graph.nodes.forEach(n => n.events &&  n.events.stop && n.events.stop(e));\r\n</script>\r\n\r\n<div class=\"graph\"\r\n\ton:touchstart={e => click(e)}\r\n\ton:mousedown={e => click(e)}\r\n\ton:touchmove={e => move(e)}\r\n\ton:mousemove={e => move(e)}\r\n\ton:touchend={e => stop(e)}\r\n\ton:mouseup={e => stop(e)}\r\n>\r\n\t{#each graph.nodes as node, i}\r\n\t\t<Node bind:node={graph.nodes[i]} />\r\n\t{/each}\r\n\t\r\n\t{#each graph.relations as relation}\r\n\t\t<NodeRelation\r\n\t\t\tsource={relation.sourcePosition}\r\n\t\t\ttarget={relation.targetPosition}/>\r\n\t{/each}\r\n</div>\r\n\r\n<style>\r\n\t.graph {\r\n\t\tposition: relative;\r\n\t\tbackground-color: #201f20;\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t}\r\n</style>",
    "<script>\r\n    import Draggable from './Draggable.svelte';\r\n    import Selectable from './Selectable.svelte';\r\n    import Socket from './Socket.svelte';\r\n\r\n    export let node;\r\n\r\n    // The top level container needs to be shared with the Draggable\r\n    // component to allow it to be dragged.\r\n    let container;\r\n\r\n    node.events = {};\r\n\r\n    // We every time the node is dragged,\r\n    // we want to update the position of all child sockets.\r\n    function drag() {\r\n        node.inputs.forEach(i => i.update && i.update());\r\n        node.outputs.forEach(o => o.update && o.update());\r\n    }\r\n</script>\r\n\r\n<Selectable bind:events={node.events} bind:container={container} absolute={true} >\r\n    <Draggable bind:events={node.events} bind:x={node.x} bind:y={node.y} on:drag={drag} container={container} title={node.name}>\r\n        <div class=\"node\">\r\n            {#if node.inputs.length > 0}\r\n                <div class=\"inputs\">\r\n                    <label>Inputs</label>\r\n                    <ul class=\"sockets\">\r\n                    {#each node.inputs as { label }, i}\r\n                        <li>\r\n                            <Socket bind:socket={node.inputs[i]} />\r\n                            <span>{label}</span>\r\n                        </li>\r\n                    {/each}\r\n                    </ul>\r\n                </div>\r\n            {/if}\r\n            {#if node.outputs.length > 0}\r\n                <div class=\"outputs\">\r\n                    <label>Outputs</label>\r\n                    <ul class=\"sockets\">\r\n                    {#each node.outputs as { label }, i}\r\n                        <li>\r\n                            <span>{label}</span>\r\n                            <Socket bind:socket={node.outputs[i]} />\r\n                        </li>\r\n                    {/each}\r\n                    </ul>\r\n                </div>\r\n            {/if}\r\n        </div>\r\n    </Draggable>\r\n</Selectable>\r\n\r\n<style>\r\n\t.node {\r\n        width: 100%;\r\n        position: relative;\r\n        display: flex;\r\n        user-select: none;\r\n    }\r\n\r\n    .inputs, .outputs {\r\n        width: 100%;\r\n        padding: 0 3px;\r\n    }\r\n\r\n    label {\r\n        color: #dddddd;\r\n        font-size: x-small;\r\n        display: block;\r\n        text-align: center;\r\n    }\r\n\r\n    .sockets {\r\n        margin: 0;\r\n        padding: 0;\r\n        list-style: none;\r\n        width: 100%;\r\n    }\r\n    \r\n    .sockets li {\r\n        display: inline-flex;\r\n        width: 100%;\r\n        height: 20px;\r\n        line-height: 10px;\r\n        align-items: center;\r\n    }\r\n\r\n    .sockets li span {\r\n        width: 100%;\r\n        color: #c0bfbf;\r\n        font-size: x-small;\r\n        padding: 0 5px;\r\n    }\r\n\r\n    .inputs {\r\n        border-right: 0.5px solid black;\r\n    }\r\n\r\n    .outputs {\r\n        border-left: 0.5px solid black;\r\n    }\r\n\r\n    .inputs, .inputs .sockets, .inputs li {\r\n        float: left;\r\n        text-align: left;\r\n    }\r\n\r\n    .outputs, .outputs .sockets, .outputs li {\r\n        float: right;\r\n        text-align: right;\r\n    }\r\n</style>",
    "<script>\r\n    export let source;\r\n    export let target;\r\n    export let curvature = 100;\r\n\r\n    let targetX, targetY, sourceX, sourceY;\r\n\r\n    let cx1, cy1, cx2, cy2;\r\n    let initialized =false;\r\n    \r\n    $: if (source && target) {\r\n        // We're using horizontal Cubic Bezier curves\r\n        // So we need to define 2 target points and 2 control points.\r\n\r\n        // Determine the target points from the socket dimentions.\r\n        targetX = target.left + target.width / 2;\r\n        targetY = target.top + target.height / 2;\r\n        sourceX = source.left + source.width / 2;\r\n        sourceY = source.top + source.height / 2;\r\n\r\n        // Control points are half way from target\r\n        cx1 = targetX - (targetX - sourceX) / 2;\r\n        cx2 = sourceX + (targetX - sourceX) / 2;\r\n\r\n        // We make sure the control points dont go beyond the target nodes\r\n        // We also add extra space to increase the curvature.\r\n        cx1 = Math.max(cx1, sourceX + curvature);\r\n        cx2 = Math.min(cx1, targetX - curvature);\r\n\r\n        // Y cordinate are inline with the nodes.\r\n        cy1 = sourceY;\r\n        cy2 = targetY;\r\n\r\n        initialized = true;\r\n    }\r\n</script>\r\n\r\n{#if initialized}\r\n    <div class=\"node-relation\">\r\n        <svg>\r\n            <filter id=\"highlight\" filterUnits=\"userSpaceOnUse\" >\r\n                <feGaussianBlur stdDeviation=\"5\" in=\"SourceGraphic\"/>\r\n            </filter>\r\n            <g>\r\n                <path class=\"curve-selector\" d=\"M{sourceX},{sourceY} C{cx1}, {cy1} {cx2},{cy2} {targetX},{targetY}\" />\r\n            </g>\r\n            <g>\r\n                <path class=\"curve\" d=\"M{sourceX},{sourceY} C{cx1}, {cy1} {cx2},{cy2} {targetX},{targetY}\" />\r\n            </g>\r\n        </svg>\r\n    </div>\r\n{/if}\r\n\r\n<style>\r\n    .node-relation {\r\n        position: absolute;\r\n        pointer-events: none;\r\n        top: 0;\r\n        left: 0;\r\n        width: 100%;\r\n        height: 100%;\r\n    }\r\n\r\n    svg {\r\n        width: 100%;\r\n        height: 100%;\r\n    }\r\n\r\n    .curve-selector {\r\n        filter: url(#highlight);\r\n        fill: none;\r\n        pointer-events: all;\r\n        stroke-opacity: 0;\r\n        stroke-linecap: round;\r\n        stroke-width: 10px;\r\n        stroke: #8ca6c0;\r\n    }\r\n\r\n    .curve-selector:hover {\r\n        \r\n        stroke-opacity: 0.5;\r\n    }\r\n    \r\n    .curve {\r\n        stroke: #8ca6c0;\r\n        stroke-width: 1;\r\n        stroke-linecap: round;\r\n        fill: none;\r\n    }\r\n</style>",
    "<script>\r\n    import { createEventDispatcher } from 'svelte';\r\n\r\n\tconst dispatch = createEventDispatcher();\r\n    \r\n    // Parent events need to be passed down to allow component to be dragged. \r\n    export let events;\r\n\r\n    export let title = \"\";\r\n\r\n    let self;\r\n\r\n    // The \"draggable\" container element can be passed in as a dependancy\r\n    // if this component needs a wrapper.\r\n    export let container = null;\r\n\r\n    export let x = 0;\r\n    export let y = 0;\r\n\r\n    $: if (!container) container = self;\r\n    $: if (container) container.style.transform = \"translate3d(\" + x + \"px, \" + y + \"px, 0)\";\r\n\r\n    let dragging = false;\r\n    let initialX;\r\n    let initialY;\r\n\r\n    // Initial function for initiating drag\r\n    function dragStart(e) {\r\n        // event can be either touchstart or mousedown\r\n        if (event.type === \"touchstart\") {\r\n            initialX = e.touches[0].clientX - x;\r\n            initialY = e.touches[0].clientY - y;\r\n        } else {\r\n            initialX = e.clientX - x;\r\n            initialY = e.clientY - y;\r\n        }\r\n\r\n        events.move = drag;\r\n        events.stop = dragEnd;\r\n\r\n        dragging = true;\r\n    }\r\n\r\n    function dragEnd(event) {\r\n        initialX = x;\r\n        initialY = y;\r\n\r\n        dragging = false;\r\n\r\n        // When the drag ends, remove the events.\r\n        events.move = e => {};\r\n        events.stop = e => {};\r\n    }\r\n\r\n    function drag(e) {\r\n        if (!dragging) return;\r\n\r\n        if (e.type === \"touchmove\") {\r\n            x = e.touches[0].clientX - initialX;\r\n            y = e.touches[0].clientY - initialY;\r\n        } else {\r\n            e.preventDefault();\r\n            x = e.clientX - initialX;\r\n            y = e.clientY - initialY;\r\n        }\r\n\r\n        // Inform any listening nodes that the component is being dragged.\r\n        dispatch('drag');\r\n    }\r\n\r\n</script>\r\n\r\n<div class=\"drag\" bind:this={self}>\r\n    <div class=\"selector\"\r\n        on:touchstart={dragStart}\r\n        on:mousedown={dragStart}>\r\n        <label>{title}</label>\r\n    </div>\r\n    <slot/>\r\n</div>\r\n\r\n<style>\r\n    .selector {\r\n        width: 100%;\r\n        height: 20px;\r\n        border-bottom: 1px solid black;\r\n    }\r\n\r\n    label {\r\n        color: #dddddd;\r\n        font-size: small;\r\n        display: block;\r\n        text-align: center;\r\n    }\r\n\r\n    .drag {\r\n        margin: 0.5px;\r\n        min-width: 100px;\r\n        min-height: 50px;\r\n        user-select: none;\r\n    }\r\n\r\n    \r\n</style>",
    "<script>\r\nexport let socket = null;\r\n\r\nlet self;\r\n\r\n$: if (self) {\r\n    // Performance of this isn't great, need to look at alternative.\r\n    socket.update = () => socket.position = self.getBoundingClientRect();\r\n    socket.update();\r\n}\r\n\r\n</script>\r\n\r\n<button bind:this={self}></button>\r\n\r\n<style>\r\n    button {\r\n        outline: none;\r\n        box-sizing: content-box;\r\n        border-radius: 10px;\r\n        padding: 3px;\r\n        width: 4px;\r\n        height: 4px;\r\n        margin: 1px auto;\r\n        background-color: black;\r\n        flex-shrink: 0;\r\n        border: 0.5px solid #b3d8fc;\r\n    }\r\n\r\n    button:active {\r\n        background-clip: content-box;\r\n        background-color: #b3d8fc;\r\n    }\r\n</style>",
    "<script>\r\n    import { onMount, onDestroy } from 'svelte';\r\n\r\n    export let events;\r\n    export let absolute = false;\r\n    export let container = null;\r\n\r\n    let selected = false;\r\n    let isAbove = false;\r\n\r\n    onMount(() => events.click = handleClick);\r\n    onDestroy(() => events.click = e => {});\r\n\r\n    function handleClick(e) {\r\n        // When clicking, the mouse needs to be above the containers to be selected.\r\n        if (isAbove) selected = true;\r\n        else selected = false;\r\n    }\r\n</script>\r\n\r\n<div class=\"selectable\" class:selected class:absolute\r\n    bind:this={container}\r\n    on:mouseenter={e => isAbove = true}\r\n    on:mouseleave={e => isAbove = false}>\r\n    <slot />\r\n</div>\r\n\r\n<style>\r\n\r\n    .absolute {\r\n        position: absolute;\r\n    }\r\n\r\n    .selectable {\r\n        border: 0.5px solid;\r\n        border-radius: 7px;\r\n        padding: 0.5px;\r\n        background-color: #3a393a;\r\n    }\r\n\r\n    .selectable:hover {\r\n        border-color: #adacac;\r\n        z-index: 1;\r\n    }\r\n\r\n    .selected {\r\n        border-color: #8ca6c0;\r\n        z-index: 1;\r\n    }\r\n\r\n    .selected:hover {\r\n        border-color: #96b2ce;\r\n        border-width: 1px;\r\n        padding: 0px;\r\n        margin: 0px;\r\n    }\r\n</style>"
  ],
  "names": [],
  "mappings": "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"
}